"""\nMODULE 4 â€” Market Comparator (Phase 2 Worker)\nUsage:\n    from core.market_worker import MarketComparator\n    comparator = MarketComparator()\n    comparator.process_validated_offers()\n"""\nimport sys\nfrom pathlib import Path\nsys.path.insert(0, str(Path(__file__).resolve().parent.parent))\n\nimport logging\nimport requests\nfrom datetime import datetime\nfrom core.models import SessionLocal, OffreRetail, ProduitReference, MarketSonde, CollisionResult\nfrom core.config import SERPAPI_KEY\n\nlogger = logging.getLogger("market_worker")\n\nclass MarketComparator:\n    def __init__(self):\n        if not SERPAPI_KEY:\n            logger.warning("SERPAPI_KEY not configured.")\n        self.api_key = SERPAPI_KEY\n\n    def _search_google_shopping(self, product_name, ean=None):\n        if not self.api_key:\n            return {"prix_amazon": None, "prix_rakuten": None, "volume_ventes_estime": None, "error": "No API key"}\n        query = ean if ean and not ean.startswith("GEN-") else product_name\n        try:\n            resp = requests.get("https://serpapi.com/search.json", params={\n                "engine": "google_shopping", "q": query, "gl": "fr", "hl": "fr",\n                "api_key": self.api_key, "num": 10\n            }, timeout=15)\n            if resp.status_code != 200:\n                return {"prix_amazon": None, "prix_rakuten": None, "volume_ventes_estime": None, "error": f"HTTP {resp.status_code}"}\n            data = resp.json()\n            shopping_results = data.get("shopping_results", [])\n            prix_amazon, prix_rakuten, all_prices = None, None, []\n            for item in shopping_results:\n                price = item.get("extracted_price")\n                source = (item.get("source", "") or "").lower()\n                if price and price > 0:\n                    all_prices.append(price)\n                    if "amazon" in source and prix_amazon is None: prix_amazon = price\n                    elif "rakuten" in source and prix_rakuten is None: prix_rakuten = price\n            volume_estimate = len(shopping_results) * 50 if shopping_results else None\n            return {"prix_amazon": prix_amazon, "prix_rakuten": prix_rakuten, "volume_ventes_estime": volume_estimate, "error": None}\n        except requests.exceptions.Timeout:\n            return {"prix_amazon": None, "prix_rakuten": None, "volume_ventes_estime": None, "error": "Timeout"}\n        except Exception as e:\n            return {"prix_amazon": None, "prix_rakuten": None, "volume_ventes_estime": None, "error": str(e)[:200]}\n\n    def process_validated_offers(self):\n        db = SessionLocal()\n        stats = {"processed": 0, "success": 0, "errors": 0, "skipped": 0}\n        try:\n            validated = db.query(OffreRetail).filter(OffreRetail.validation_humaine_phase_1 == "VALIDATED").all()\n            if not validated:\n                return stats\n            for offre in validated:\n                stats["processed"] += 1\n                produit = db.query(ProduitReference).filter(ProduitReference.ean == offre.ean).first()\n                product_name = produit.nom_genere if produit else offre.ean\n                market_data = self._search_google_shopping(product_name, offre.ean)\n                if market_data.get("error"):\n                    stats["errors"] += 1\n                    continue\n                sonde = db.query(MarketSonde).filter(MarketSonde.ean == offre.ean, MarketSonde.marketplace == "google_shopping").first()\n                if not sonde:\n                    sonde = MarketSonde(ean=offre.ean, marketplace="google_shopping", buy_box=market_data["prix_amazon"] or 0.0)\n                    db.add(sonde)\n                sonde.prix_amazon = market_data["prix_amazon"]\n                sonde.prix_rakuten = market_data["prix_rakuten"]\n                sonde.volume_ventes_estime = market_data["volume_ventes_estime"]\n                sonde.timestamp = datetime.utcnow()\n                if market_data["prix_amazon"]: sonde.buy_box = market_data["prix_amazon"]\n                collisions = db.query(CollisionResult).filter(CollisionResult.ean == offre.ean, CollisionResult.offre_id == offre.id).all()\n                for c in collisions: c.certification_finale = "PENDING_PHASE2"\n                db.commit()\n                stats["success"] += 1\n        except Exception as e:\n            db.rollback()\n            stats["errors"] += 1\n        finally:\n            db.close()\n        return stats\n\nif __name__ == "__main__":\n    logging.basicConfig(level=logging.INFO)\n    print(MarketComparator().process_validated_offers())\n